{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Set up conditional compilation in Cargo.toml",
        "description": "Configure Cargo.toml with platform-specific dependencies for Windows and Unix systems",
        "details": "Update Cargo.toml to include:\n1. Windows-specific dependencies using the `windows` crate\n2. Unix-specific dependencies using `nix` and `mio` crates\n3. Set up feature flags for conditional compilation\n\nExample configuration:\n```toml\n[dependencies]\n# Common dependencies for all platforms\ntokio = { version = \"1\", features = [\"full\"] }\nserde = { version = \"1\", features = [\"derive\"] }\nserde_json = \"1\"\n\n# Platform-specific dependencies\n[target.'cfg(unix)'.dependencies]\nnix = \"0.26\"\nmio = \"0.8\"\n\n[target.'cfg(windows)'.dependencies]\nwindows = { version = \"0.48\", features = [\"Win32_System_Console\", \"Win32_Foundation\", \"Win32_System_Threading\"] }\n```",
        "testStrategy": "Verify that the project builds successfully on both Unix and Windows platforms. Use GitHub Actions to validate cross-platform compilation.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Create platform abstraction interface for PTY",
        "description": "Design and implement a common interface for PTY operations that will work across both Unix and Windows platforms",
        "details": "1. Create a trait or interface that defines common PTY operations:\n```rust\npub trait PtyProvider {\n    fn spawn(&self, command: &str, args: &[&str], cwd: Option<&str>) -> Result<PtyProcess, PtyError>;\n    fn resize(&self, process: &mut PtyProcess, rows: u16, cols: u16) -> Result<(), PtyError>;\n    fn read(&self, process: &mut PtyProcess, buf: &mut [u8]) -> Result<usize, PtyError>;\n    fn write(&self, process: &mut PtyProcess, buf: &[u8]) -> Result<usize, PtyError>;\n    fn kill(&self, process: &mut PtyProcess) -> Result<(), PtyError>;\n}\n\npub struct PtyProcess {\n    // Common fields for both platforms\n    pub pid: u32,\n    // Platform-specific fields will be added with conditional compilation\n}\n```\n\n2. Create a factory function to return the appropriate implementation:\n```rust\npub fn create_pty_provider() -> Box<dyn PtyProvider> {\n    #[cfg(unix)]\n    {\n        Box::new(UnixPtyProvider::new())\n    }\n    \n    #[cfg(windows)]\n    {\n        Box::new(WindowsPtyProvider::new())\n    }\n}\n```",
        "testStrategy": "Create unit tests that verify the interface can be implemented for both platforms. Test that the factory function returns the correct implementation based on the platform.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Implement Unix PTY provider",
        "description": "Implement the PTY provider interface for Unix systems using the existing functionality",
        "details": "1. Create a Unix-specific implementation of the PtyProvider trait:\n```rust\n#[cfg(unix)]\npub struct UnixPtyProcess {\n    pub pid: u32,\n    pub master_fd: RawFd,\n    pub child_process: Child,\n}\n\n#[cfg(unix)]\npub struct UnixPtyProvider {}\n\n#[cfg(unix)]\nimpl UnixPtyProvider {\n    pub fn new() -> Self {\n        UnixPtyProvider {}\n    }\n}\n\n#[cfg(unix)]\nimpl PtyProvider for UnixPtyProvider {\n    fn spawn(&self, command: &str, args: &[&str], cwd: Option<&str>) -> Result<PtyProcess, PtyError> {\n        // Implement using existing Unix PTY code\n        // Use nix::pty::openpty() and related functions\n    }\n    \n    // Implement other methods...\n}\n```\n\n2. Refactor existing Unix PTY code to use this new abstraction while maintaining the same functionality",
        "testStrategy": "Run existing Unix tests against the new implementation to ensure functionality is preserved. Verify that all Unix-specific features continue to work as expected.",
        "priority": "medium",
        "dependencies": [
          2
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Implement Windows PTY provider using process pipes",
        "description": "Create a Windows implementation of the PTY provider interface using tokio::process with piped stdio",
        "details": "1. Create a Windows-specific implementation of the PtyProvider trait:\n```rust\n#[cfg(windows)]\npub struct WindowsPtyProcess {\n    pub pid: u32,\n    pub child_process: tokio::process::Child,\n    pub stdin: Option<ChildStdin>,\n    pub stdout: Option<ChildStdout>,\n    pub stderr: Option<ChildStderr>,\n}\n\n#[cfg(windows)]\npub struct WindowsPtyProvider {}\n\n#[cfg(windows)]\nimpl WindowsPtyProvider {\n    pub fn new() -> Self {\n        WindowsPtyProvider {}\n    }\n}\n\n#[cfg(windows)]\nimpl PtyProvider for WindowsPtyProvider {\n    fn spawn(&self, command: &str, args: &[&str], cwd: Option<&str>) -> Result<PtyProcess, PtyError> {\n        let mut cmd = tokio::process::Command::new(command);\n        cmd.args(args)\n           .stdin(Stdio::piped())\n           .stdout(Stdio::piped())\n           .stderr(Stdio::piped());\n        \n        if let Some(dir) = cwd {\n            cmd.current_dir(dir);\n        }\n        \n        // Create process with piped stdio\n        let mut child = cmd.spawn().map_err(|e| PtyError::SpawnError(e.to_string()))?;\n        \n        let pid = child.id().unwrap_or(0);\n        let stdin = child.stdin.take();\n        let stdout = child.stdout.take();\n        let stderr = child.stderr.take();\n        \n        Ok(PtyProcess {\n            pid,\n            child_process: child,\n            stdin,\n            stdout,\n            stderr,\n        })\n    }\n    \n    // Implement other methods...\n}\n```\n\n2. Implement read/write methods using async I/O with the piped stdio\n3. Implement process termination using Windows-specific APIs",
        "testStrategy": "Create Windows-specific tests that verify process spawning, I/O operations, and termination work correctly. Test with both cmd.exe and PowerShell as target shells.",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Implement platform-specific error handling",
        "description": "Create error types and handling mechanisms for Windows-specific errors while maintaining Unix error compatibility",
        "details": "1. Create a common error enum that works across platforms:\n```rust\n#[derive(Debug, thiserror::Error)]\npub enum PtyError {\n    #[error(\"Failed to spawn process: {0}\")]\n    SpawnError(String),\n    \n    #[error(\"I/O error: {0}\")]\n    IoError(#[from] std::io::Error),\n    \n    #[error(\"Failed to resize terminal: {0}\")]\n    ResizeError(String),\n    \n    #[error(\"Process terminated unexpectedly: {0}\")]\n    ProcessTerminated(String),\n    \n    // Platform-specific errors\n    #[cfg(unix)]\n    #[error(\"Unix PTY error: {0}\")]\n    UnixPtyError(String),\n    \n    #[cfg(windows)]\n    #[error(\"Windows process error: {0}\")]\n    WindowsProcessError(String),\n}\n```\n\n2. Implement platform-specific error conversion functions\n3. Add detailed error context for Windows-specific failures",
        "testStrategy": "Create tests that verify error handling for various failure scenarios on both platforms. Ensure error messages are clear and helpful for debugging.",
        "priority": "medium",
        "dependencies": [
          3,
          4
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Implement Windows console size management",
        "description": "Create functionality to get and set console window size on Windows platforms",
        "details": "1. Use the Windows API to manage console size:\n```rust\n#[cfg(windows)]\nimpl WindowsPtyProvider {\n    fn resize_console(&self, process: &mut WindowsPtyProcess, rows: u16, cols: u16) -> Result<(), PtyError> {\n        use windows::Win32::System::Console::{GetStdHandle, SetConsoleScreenBufferSize};\n        use windows::Win32::System::Console::{CONSOLE_SCREEN_BUFFER_INFO, GetConsoleScreenBufferInfo};\n        use windows::Win32::Foundation::HANDLE;\n        \n        // Get console handle\n        let console_handle = unsafe { GetStdHandle(STD_OUTPUT_HANDLE) };\n        \n        // Create new size info\n        let size = COORD { X: cols as i16, Y: rows as i16 };\n        \n        // Set the console size\n        let result = unsafe { SetConsoleScreenBufferSize(console_handle, size) };\n        if result.is_err() {\n            return Err(PtyError::ResizeError(\"Failed to resize Windows console\".to_string()));\n        }\n        \n        Ok(())\n    }\n}\n\n#[cfg(windows)]\nimpl PtyProvider for WindowsPtyProvider {\n    // ... other methods\n    \n    fn resize(&self, process: &mut PtyProcess, rows: u16, cols: u16) -> Result<(), PtyError> {\n        let windows_process = process.as_windows_process_mut()?;\n        self.resize_console(windows_process, rows, cols)\n    }\n}\n```\n\n2. Implement functions to query the current console size\n3. Handle errors when console size operations fail",
        "testStrategy": "Test resize operations with various window sizes. Verify that the console size is correctly set and that the application running in the console receives the correct size information.",
        "priority": "medium",
        "dependencies": [
          4
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Implement Windows shell integration",
        "description": "Add support for spawning and controlling both cmd.exe and PowerShell sessions on Windows",
        "details": "1. Create shell detection and configuration:\n```rust\n#[cfg(windows)]\npub enum WindowsShell {\n    Cmd,\n    PowerShell,\n    Custom(String),\n}\n\n#[cfg(windows)]\nimpl WindowsPtyProvider {\n    pub fn spawn_shell(&self, shell_type: WindowsShell, cwd: Option<&str>) -> Result<PtyProcess, PtyError> {\n        match shell_type {\n            WindowsShell::Cmd => {\n                self.spawn(\"cmd.exe\", &[\"/c\"], cwd)\n            },\n            WindowsShell::PowerShell => {\n                self.spawn(\"powershell.exe\", &[\"-NoLogo\", \"-NoExit\"], cwd)\n            },\n            WindowsShell::Custom(cmd) => {\n                // Parse command and args\n                let parts: Vec<&str> = cmd.split_whitespace().collect();\n                if parts.is_empty() {\n                    return Err(PtyError::SpawnError(\"Empty command\".to_string()));\n                }\n                \n                let command = parts[0];\n                let args = &parts[1..];\n                self.spawn(command, args, cwd)\n            }\n        }\n    }\n}\n```\n\n2. Add shell-specific command formatting for each shell type\n3. Handle shell-specific quirks and initialization",
        "testStrategy": "Test spawning both cmd.exe and PowerShell. Verify that commands can be executed in both shell types and that output is correctly captured. Test shell-specific commands and verify they work as expected.",
        "priority": "high",
        "dependencies": [
          4
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Implement platform-specific locale handling",
        "description": "Create locale detection and UTF-8 support for Windows platforms",
        "details": "1. Create platform-specific locale detection:\n```rust\n#[cfg(unix)]\npub fn detect_locale() -> String {\n    // Existing Unix implementation\n    std::env::var(\"LANG\").unwrap_or_else(|_| \"en_US.UTF-8\".to_string())\n}\n\n#[cfg(windows)]\npub fn detect_locale() -> String {\n    use windows::Win32::System::SystemInformation::{GetSystemDefaultLCID, GetUserDefaultLCID};\n    use windows::Win32::System::SystemServices::LOCALE_NAME_MAX_LENGTH;\n    use windows::Win32::Globalization::GetLocaleInfoEx;\n    \n    // Get system locale ID\n    let lcid = unsafe { GetUserDefaultLCID() };\n    \n    // Convert to locale name\n    let mut buffer = [0u16; LOCALE_NAME_MAX_LENGTH as usize];\n    let result = unsafe { GetLocaleInfoEx(lcid, LOCALE_SNAME, &mut buffer, LOCALE_NAME_MAX_LENGTH) };\n    \n    if result > 0 {\n        // Convert from wide string to UTF-8\n        let locale = String::from_utf16_lossy(&buffer[..result as usize]);\n        locale\n    } else {\n        // Default fallback\n        \"en-US\".to_string()\n    }\n}\n```\n\n2. Implement UTF-8 code page setting for Windows console\n3. Handle Windows-specific character encoding issues",
        "testStrategy": "Test locale detection on different Windows configurations. Verify that UTF-8 characters are correctly handled in both input and output. Test with non-ASCII characters in commands and output.",
        "priority": "medium",
        "dependencies": [
          4
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Implement non-blocking I/O for Windows",
        "description": "Create Windows-specific non-blocking I/O helpers for process communication",
        "details": "1. Implement non-blocking I/O for Windows process pipes:\n```rust\n#[cfg(windows)]\npub struct WindowsNonBlockingIO {\n    stdin_writer: Option<tokio::io::BufWriter<ChildStdin>>,\n    stdout_reader: Option<tokio::io::BufReader<ChildStdout>>,\n    stderr_reader: Option<tokio::io::BufReader<ChildStderr>>,\n}\n\n#[cfg(windows)]\nimpl WindowsNonBlockingIO {\n    pub fn new(\n        stdin: Option<ChildStdin>,\n        stdout: Option<ChildStdout>,\n        stderr: Option<ChildStderr>,\n    ) -> Self {\n        let stdin_writer = stdin.map(|s| tokio::io::BufWriter::new(s));\n        let stdout_reader = stdout.map(|s| tokio::io::BufReader::new(s));\n        let stderr_reader = stderr.map(|s| tokio::io::BufReader::new(s));\n        \n        Self {\n            stdin_writer,\n            stdout_reader,\n            stderr_reader,\n        }\n    }\n    \n    pub async fn read_stdout(&mut self, buf: &mut [u8]) -> Result<usize, std::io::Error> {\n        if let Some(reader) = &mut self.stdout_reader {\n            use tokio::io::AsyncReadExt;\n            reader.read(buf).await\n        } else {\n            Ok(0)\n        }\n    }\n    \n    pub async fn write_stdin(&mut self, buf: &[u8]) -> Result<usize, std::io::Error> {\n        if let Some(writer) = &mut self.stdin_writer {\n            use tokio::io::AsyncWriteExt;\n            writer.write(buf).await\n        } else {\n            Ok(0)\n        }\n    }\n}\n```\n\n2. Integrate with the Windows PTY provider implementation\n3. Ensure proper error handling for I/O operations",
        "testStrategy": "Test reading and writing to Windows processes with various buffer sizes. Verify that non-blocking I/O works correctly and doesn't cause deadlocks. Test with high-volume I/O to ensure performance.",
        "priority": "high",
        "dependencies": [
          4
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Implement Windows process lifecycle management",
        "description": "Create functionality to properly manage Windows process creation, monitoring, and termination",
        "details": "1. Implement process lifecycle management:\n```rust\n#[cfg(windows)]\nimpl WindowsPtyProvider {\n    pub fn terminate_process(&self, process: &mut WindowsPtyProcess) -> Result<(), PtyError> {\n        use windows::Win32::System::Threading::{OpenProcess, TerminateProcess};\n        use windows::Win32::Foundation::{HANDLE, BOOL};\n        \n        // Try graceful termination first\n        if let Err(e) = process.child_process.kill() {\n            // If graceful termination fails, use TerminateProcess\n            let pid = process.pid;\n            let process_handle = unsafe { OpenProcess(PROCESS_TERMINATE, BOOL(0), pid) };\n            \n            if process_handle.is_err() {\n                return Err(PtyError::ProcessTerminated(\n                    format!(\"Failed to open process handle: {}\", e)\n                ));\n            }\n            \n            let result = unsafe { TerminateProcess(process_handle.unwrap(), 1) };\n            if result.is_err() {\n                return Err(PtyError::ProcessTerminated(\n                    \"Failed to terminate Windows process\".to_string()\n                ));\n            }\n        }\n        \n        Ok(())\n    }\n    \n    pub async fn wait_for_exit(&self, process: &mut WindowsPtyProcess) -> Result<i32, PtyError> {\n        match process.child_process.wait().await {\n            Ok(status) => Ok(status.code().unwrap_or(-1)),\n            Err(e) => Err(PtyError::ProcessTerminated(e.to_string())),\n        }\n    }\n}\n```\n\n2. Implement process status checking\n3. Handle process cleanup and resource management",
        "testStrategy": "Test process creation, monitoring, and termination. Verify that processes are properly cleaned up when terminated. Test with long-running processes and ensure resources are not leaked.",
        "priority": "high",
        "dependencies": [
          4,
          9
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 11,
        "title": "Implement JSON API compatibility layer",
        "description": "Ensure the JSON API works identically across Unix and Windows platforms",
        "details": "1. Create a platform-agnostic JSON API handler:\n```rust\npub struct JsonApiHandler {\n    pty_provider: Box<dyn PtyProvider>,\n    active_sessions: HashMap<String, PtySession>,\n}\n\npub struct PtySession {\n    process: PtyProcess,\n    id: String,\n    created_at: SystemTime,\n}\n\nimpl JsonApiHandler {\n    pub fn new() -> Self {\n        let pty_provider = create_pty_provider();\n        Self {\n            pty_provider,\n            active_sessions: HashMap::new(),\n        }\n    }\n    \n    pub fn handle_request(&mut self, request: JsonRequest) -> JsonResponse {\n        match request.action.as_str() {\n            \"create_session\" => self.create_session(request),\n            \"write\" => self.write_to_session(request),\n            \"read\" => self.read_from_session(request),\n            \"resize\" => self.resize_session(request),\n            \"terminate\" => self.terminate_session(request),\n            _ => JsonResponse::error(\"Unknown action\"),\n        }\n    }\n    \n    // Implement other methods...\n}\n```\n\n2. Ensure all API methods work consistently across platforms\n3. Handle platform-specific quirks in the API implementation",
        "testStrategy": "Create comprehensive API tests that run on both platforms. Verify that the same JSON requests produce equivalent responses on both Unix and Windows. Test all API endpoints with various inputs.",
        "priority": "high",
        "dependencies": [
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 12,
        "title": "Set up Windows CI pipeline",
        "description": "Create a GitHub Actions workflow for building and testing on Windows",
        "details": "1. Create a GitHub Actions workflow file for Windows:\n```yaml\nname: Windows Build and Test\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n\njobs:\n  build:\n    runs-on: windows-latest\n    steps:\n    - uses: actions/checkout@v2\n    - name: Install Rust\n      uses: actions-rs/toolchain@v1\n      with:\n        toolchain: stable\n        profile: minimal\n        override: true\n    - name: Build\n      uses: actions-rs/cargo@v1\n      with:\n        command: build\n    - name: Run tests\n      uses: actions-rs/cargo@v1\n      with:\n        command: test\n    - name: Run integration tests\n      run: |\n        cargo run -- --test-mode\n```\n\n2. Add Windows-specific test cases\n3. Configure CI to run tests with both cmd.exe and PowerShell",
        "testStrategy": "Verify that the CI pipeline successfully builds and tests the project on Windows. Ensure all tests pass on the Windows CI environment.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 13,
        "title": "Implement cross-compilation support",
        "description": "Set up cross-compilation from Unix to Windows",
        "details": "1. Configure cross-compilation toolchain:\n```bash\n# Install cross-compilation tools\nrustup target add x86_64-pc-windows-msvc\n\n# Create .cargo/config.toml with linker configuration\nmkdir -p .cargo\ncat > .cargo/config.toml << EOF\n[target.x86_64-pc-windows-msvc]\nlinker = \"lld\"\nrustflags = [\"-C\", \"link-arg=-fuse-ld=lld\"]\nEOF\n```\n\n2. Create a build script for cross-compilation:\n```bash\n#!/bin/bash\nset -e\n\n# Build for Windows\ncargo build --target x86_64-pc-windows-msvc\n\n# Output binary location\necho \"Windows binary built at: target/x86_64-pc-windows-msvc/debug/ht.exe\"\n```\n\n3. Document cross-compilation process in README.md",
        "testStrategy": "Verify that the project can be cross-compiled from Unix to Windows. Test the resulting Windows binary in a Windows environment or using Wine on Unix.",
        "priority": "medium",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 14,
        "title": "Create Windows-specific integration tests",
        "description": "Develop integration tests for Windows-specific functionality",
        "details": "1. Create Windows-specific test cases:\n```rust\n#[cfg(test)]\n#[cfg(windows)]\nmod windows_tests {\n    use super::*;\n    \n    #[test]\n    fn test_cmd_execution() {\n        let provider = WindowsPtyProvider::new();\n        let mut process = provider.spawn(\"cmd.exe\", &[\"/c\", \"echo Hello Windows\"], None).unwrap();\n        \n        // Write command\n        provider.write(&mut process, b\"dir\\r\\n\").unwrap();\n        \n        // Read output\n        let mut buf = [0u8; 1024];\n        let n = provider.read(&mut process, &mut buf).unwrap();\n        let output = String::from_utf8_lossy(&buf[0..n]);\n        \n        assert!(output.contains(\"Hello Windows\"));\n        \n        // Clean up\n        provider.kill(&mut process).unwrap();\n    }\n    \n    #[test]\n    fn test_powershell_execution() {\n        let provider = WindowsPtyProvider::new();\n        let mut process = provider.spawn(\"powershell.exe\", &[\"-NoLogo\"], None).unwrap();\n        \n        // Write command\n        provider.write(&mut process, b\"Get-Process | Select-Object -First 3\\r\\n\").unwrap();\n        \n        // Read output\n        let mut buf = [0u8; 1024];\n        let n = provider.read(&mut process, &mut buf).unwrap();\n        let output = String::from_utf8_lossy(&buf[0..n]);\n        \n        assert!(output.contains(\"Process\"));\n        \n        // Clean up\n        provider.kill(&mut process).unwrap();\n    }\n}\n```\n\n2. Create integration tests for the JSON API on Windows\n3. Add tests for Windows-specific error scenarios",
        "testStrategy": "Run the integration tests on Windows CI. Verify that all Windows-specific functionality works as expected. Test with various Windows commands and applications.",
        "priority": "medium",
        "dependencies": [
          4,
          7,
          10,
          11
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 15,
        "title": "Create Windows usage documentation",
        "description": "Develop comprehensive documentation for Windows usage and platform-specific considerations",
        "details": "1. Create Windows-specific documentation in README.md:\n```markdown\n## Windows Support\n\nHT now supports Windows platforms in addition to Unix-like systems. The Windows implementation uses process pipes as a substitute for PTY functionality.\n\n### Windows Requirements\n\n- Windows 10 or later\n- Rust toolchain with the `x86_64-pc-windows-msvc` target\n\n### Windows-Specific Usage\n\n```powershell\n# Start a PowerShell session\nht spawn --shell powershell\n\n# Start a cmd.exe session\nht spawn --shell cmd\n\n# Specify window size\nht spawn --shell powershell --rows 24 --cols 80\n```\n\n### Windows Limitations\n\n- Limited signal handling compared to Unix\n- Uses process pipes instead of true PTY\n- Some terminal applications may not work as expected\n```\n\n2. Document platform-specific API differences\n3. Add troubleshooting section for common Windows issues",
        "testStrategy": "Review documentation for accuracy and completeness. Verify that all Windows-specific features and limitations are properly documented. Test the documented examples to ensure they work as described.",
        "priority": "medium",
        "dependencies": [
          11,
          14
        ],
        "status": "done",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-06-16T22:21:47.075Z",
      "updated": "2025-06-16T22:25:37.565Z",
      "description": "Tasks for master context"
    }
  }
}